
import SwiftUI

// 試合記録追加ビュー
struct AddMatchRecordView: View {
    let deckId: String
    @ObservedObject var viewModel: DeckListViewModel
    let onDismiss: () -> Void

    @State private var selectedInkColors: Set<Ink> = []
    @State private var opponentDeckName: String = ""
    @State private var previousInkColors: Set<Ink> = []  // 以前のインクの組み合わせを追跡
    @State private var isWin: Bool? = nil  // nil: 未選択, true: 勝利, false: 敗北
    @State private var playedAt: Date = Date()

    var body: some View {
        NavigationStack {
            ScrollView {
                VStack(alignment: .leading, spacing: 20) {
                    // 勝敗選択
                    VStack(alignment: .leading, spacing: 8) {
                        Text(String(localized: "勝敗"))
                            .font(.subheadline)
                            .foregroundColor(.primary)

                        HStack(spacing: 12) {
                            // 勝利ボタン
                            Button {
                                isWin = isWin == true ? nil : true
                            } label: {
                                HStack(spacing: 6) {
                                    Image(systemName: "checkmark.circle.fill")
                                        .font(.subheadline)
                                    Text(String(localized: "勝利"))
                                        .font(.subheadline)
                                        .fontWeight(.medium)
                                }
                                .frame(maxWidth: .infinity)
                                .padding(.vertical, 12)
                                .background(isWin == true ? Color.green.opacity(0.2) : Color.gray.opacity(0.1))
                                .foregroundColor(isWin == true ? .green : .secondary)
                                .cornerRadius(8)
                                .overlay(
                                    RoundedRectangle(cornerRadius: 8)
                                        .stroke(isWin == true ? Color.green : Color.clear, lineWidth: 2)
                                )
                            }
                            .buttonStyle(.plain)

                            // 敗北ボタン
                            Button {
                                isWin = isWin == false ? nil : false
                            } label: {
                                HStack(spacing: 6) {
                                    Image(systemName: "xmark.circle.fill")
                                        .font(.subheadline)
                                    Text(String(localized: "敗北"))
                                        .font(.subheadline)
                                        .fontWeight(.medium)
                                }
                                .frame(maxWidth: .infinity)
                                .padding(.vertical, 12)
                                .background(isWin == false ? Color.red.opacity(0.2) : Color.gray.opacity(0.1))
                                .foregroundColor(isWin == false ? .red : .secondary)
                                .cornerRadius(8)
                                .overlay(
                                    RoundedRectangle(cornerRadius: 8)
                                        .stroke(isWin == false ? Color.red : Color.clear, lineWidth: 2)
                                )
                            }
                            .buttonStyle(.plain)
                        }
                    }
                    .padding(.horizontal, 16)

                    // 相手のデッキ名入力
                    VStack(alignment: .leading, spacing: 6) {
                        Text(String(localized: "相手のデッキ名"))
                            .font(.subheadline)
                            .foregroundColor(.primary)

                        TextField(String(localized: "未入力の場合はインク名になります"), text: $opponentDeckName)
                            .textFieldStyle(.roundedBorder)
                            .onChange(of: selectedInkColors) { oldValue, newValue in
                                // インク色が変更されたら、名前が空または自動生成された名前の場合は更新
                                let trimmedName = opponentDeckName.trimmingCharacters(
                                    in: .whitespacesAndNewlines)
                                if trimmedName.isEmpty
                                    || isAutoGeneratedName(trimmedName, previousColors: oldValue)
                                {
                                    updateDeckNameFromInkColors()
                                    previousInkColors = newValue
                                } else {
                                    previousInkColors = newValue
                                }
                            }
                    }
                    .padding(.horizontal, 16)

                    // 相手のインク色選択
                    VStack(alignment: .leading, spacing: 8) {
                        Text(String(localized: "相手のインク（最大2色）"))
                            .font(.subheadline)
                            .foregroundColor(.primary)

                        let columns = Array(repeating: GridItem(.flexible(), spacing: 8), count: 2)
                        LazyVGrid(columns: columns, spacing: 8) {
                            ForEach(Ink.allCases) { inkColor in
                                opponentInkColorChip(inkColor: inkColor)
                                    .frame(maxWidth: .infinity)
                            }
                        }
                        .padding(.top, 2)
                    }
                    .padding(.horizontal, 16)

                    // 試合日時選択
                    VStack(alignment: .leading, spacing: 8) {
                        Text(String(localized: "試合日時"))
                            .font(.subheadline)
                            .foregroundColor(.primary)

                        DatePicker(
                            String(localized: "試合日時"),
                            selection: $playedAt,
                            displayedComponents: [.date, .hourAndMinute]
                        )
                        .datePickerStyle(.compact)
                    }
                    .padding(.horizontal, 16)
                }
                .padding(.vertical)
            }
            .background(Color(.systemGroupedBackground))
            .navigationTitle(String(localized: "試合記録を追加"))
            .navigationBarTitleDisplayMode(.inline)
            .onAppear {
                // シートが開かれたときに以前のインクをリセット
                previousInkColors = selectedInkColors
            }
            .toolbar {
                ToolbarItem(placement: .cancellationAction) {
                    Button {
                        onDismiss()
                    } label: {
                        Image(systemName: "xmark")
                    }
                }

                ToolbarItem(placement: .confirmationAction) {
                    Button {
                        addMatchRecord()
                    } label: {
                        Image(systemName: "checkmark")
                    }
                    .disabled(isWin == nil)
                }
            }
        }
    }

    private func opponentInkColorChip(inkColor: Ink) -> some View {
        let isSelected = selectedInkColors.contains(inkColor)
        let canSelect = selectedInkColors.count < 2 || isSelected

        return Button {
            let oldColors = selectedInkColors
            if isSelected {
                selectedInkColors.remove(inkColor)
                // 名前が空または自動生成された名前の場合は更新
                let trimmedName = opponentDeckName.trimmingCharacters(in: .whitespacesAndNewlines)
                if trimmedName.isEmpty
                    || isAutoGeneratedName(trimmedName, previousColors: oldColors)
                {
                    updateDeckNameFromInkColors()
                    previousInkColors = selectedInkColors
                } else {
                    previousInkColors = selectedInkColors
                }
            } else if canSelect {
                selectedInkColors.insert(inkColor)
                // 名前が空または自動生成された名前の場合は更新
                let trimmedName = opponentDeckName.trimmingCharacters(in: .whitespacesAndNewlines)
                if trimmedName.isEmpty
                    || isAutoGeneratedName(trimmedName, previousColors: oldColors)
                {
                    updateDeckNameFromInkColors()
                    previousInkColors = selectedInkColors
                } else {
                    previousInkColors = selectedInkColors
                }
            }
        } label: {
            HStack(spacing: 6) {
                Circle()
                    .fill(inkColor.color)
                    .frame(width: 8, height: 8)

                Text(inkColor.japaneseName)
                    .font(.caption)
                    .fontWeight(isSelected ? .semibold : .regular)
            }
            .frame(maxWidth: .infinity)
            .padding(.horizontal, 10)
            .padding(.vertical, 6)
            .background(
                RoundedRectangle(cornerRadius: 999)
                    .fill(isSelected ? Color.accentColor.opacity(0.2) : Color.gray.opacity(0.1))
            )
            .overlay(
                RoundedRectangle(cornerRadius: 999)
                    .stroke(isSelected ? Color.accentColor : Color.clear, lineWidth: 2)
            )
            .opacity(canSelect ? 1.0 : 0.5)
        }
        .buttonStyle(.plain)
        .animation(.easeInOut(duration: 0.2), value: isSelected)
    }

    // 現在の名前が以前のインク色の組み合わせから自動生成された名前かどうかをチェック
    private func isAutoGeneratedName(_ name: String, previousColors: Set<Ink>) -> Bool {
        let colors = Array(previousColors).sorted { $0.rawValue < $1.rawValue }
        let autoGeneratedName = Ink.generateDeckName(colors: colors)
        // 空の場合は自動生成された名前とみなす
        if autoGeneratedName.isEmpty {
            return name.isEmpty
        }
        return name == autoGeneratedName
    }

    // インク色からデッキ名を更新
    private func updateDeckNameFromInkColors() {
        let colors = Array(selectedInkColors).sorted { $0.rawValue < $1.rawValue }
        opponentDeckName = Ink.generateDeckName(colors: colors)
    }

    private func addMatchRecord() {
        guard let isWinValue = isWin else { return }  // 未選択の場合は追加しない
        
        let inkColors = Array(selectedInkColors).sorted { $0.rawValue < $1.rawValue }
        let trimmedName = opponentDeckName.trimmingCharacters(in: .whitespacesAndNewlines)
        let record = MatchRecord(
            opponentInkColors: inkColors,
            opponentDeckName: trimmedName,
            isWin: isWinValue,
            playedAt: playedAt
        )
        
        // デッキ名を取得
        let deck = viewModel.decks.first { $0.id == deckId }
        let deckName = deck?.name ?? ""
        
        // 相手のインク色を文字列配列に変換
        let opponentInkColorStrings = inkColors.map { $0.rawValue }
        
        // 試合日時をISO8601形式の文字列に変換
        let formatter = ISO8601DateFormatter()
        formatter.formatOptions = [.withInternetDateTime, .withFractionalSeconds]
        let playedAtString = formatter.string(from: playedAt)
        
        // イベント送信
        AnalyticsManager.shared.logMatchRecordAddComplete(
            isWin: isWinValue,
            deckName: deckName,
            opponentInkColors: opponentInkColorStrings,
            playedAt: playedAtString
        )
        
        viewModel.addMatchRecord(deckId, record: record)
        onDismiss()
    }
}

